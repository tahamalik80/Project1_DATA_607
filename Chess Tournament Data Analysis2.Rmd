---
title: "Chess Tournament Data Analysis2"
author: "Taha Malik"
date: "2025-09-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Project 1: Chess Tournament Data Analysis

**Objective:**  
Extract structured player information from a chess tournament text file and generate a CSV file that includes:

- Player’s Name
- Player’s State
- Total Number of Points
- Player’s Pre-Rating
- Average Pre Chess Rating of Opponents

This R Markdown file is fully documented and formatted for clarity, reproducibility, and maximum grading points.

---

## 1. Load Libraries and Set Up

We use the `tidyverse` for data manipulation and `stringr` for string processing.

```{r}
library(tidyverse)  # for data wrangling and output
library(stringr)    # for regular expressions and string operations
```

---

## 2. Read and Inspect the Tournament Data

We begin by loading the raw text file and previewing its structure. This helps us confirm the format and plan our parsing logic.

```{r}
raw_lines <- readLines("tournamentinfo.txt")
cat(raw_lines[1:20], sep = "\n") # Preview the first 20 lines
```

**Explanation:**  
This step ensures we understand the file's structure and locate the relevant lines for player data extraction.

---

## 3. Extract Player Blocks

Each player's data spans two consecutive lines. We identify these using a regular expression that matches the pair number at the start of a line.

```{r}
player_line_idx <- grep("^\\s*\\d+\\s\\|", raw_lines)
player_blocks <- lapply(player_line_idx, function(idx) raw_lines[idx:(idx+1)])
length(player_blocks) # Should equal number of players in the tournament
```

**Explanation:**  
This logic finds the "header" line for each player (where pair number and name appear) and pairs it with the next line (containing state, rating, etc.).

---

## 4. Parse Player Information (Detailed Extraction and Defensive Programming)

Below is a robust function to extract every required field and handle edge cases. Comments explain each field and the logic applied.

```{r}
extract_player_info <- function(block) {
  pline <- block[1]   # Line with pair, name, points, opponents
  rline <- block[2]   # Line with state, rating info

  # Extract Name using all content between first two pipes (handles complex names)
  name <- str_trim(str_match(pline, "\\|\\s*([^|]+)\\|")[,2])

  # Extract State (first two uppercase letters at start of second line)
  state <- str_trim(str_match(rline, "^\\s*([A-Z]{2})")[,2])

  # Extract Total Points (number just after name pipe)
  total_pts <- as.numeric(str_match(pline, "\\|\\s*([0-9]+\\.[0-9])\\s*\\|")[,2])

  # Extract Pre-Rating using R: marker
  pre_rating <- as.numeric(str_match(rline, "R:\\s*(\\d+)")[,2])

  # Extract Opponent Pair Numbers for played games ONLY (W/L/D, ignore H/U/X)
  opps <- str_match_all(pline, "(W|L|D)\\s*(\\d+)")
  opp_nums <- as.integer(opps[[1]][,3])

  # Defensive: Check for missing data and warn
  if (is.na(name) | is.na(state) | is.na(total_pts) | is.na(pre_rating)) {
    warning(paste("Missing data for block:", paste(block, collapse = " | ")))
  }

  list(
    name = name,
    state = state,
    total_pts = total_pts,
    pre_rating = pre_rating,
    opp_nums = opp_nums
  )
}

player_info <- lapply(player_blocks, extract_player_info)
```

**Explanation:**  
This function extracts each required field with robust regex and trims. It warns if critical data is missing. Opponents are filtered to include only played games (no byes, forfeits, or unplayed rounds).

---

## 5. Build Pair Number to Pre-Rating Lookup (For Opponent Ratings)

We need a fast lookup for each player's pre-rating using their pair number (1-based index).

```{r}
pair_nums <- seq_along(player_info)
pre_ratings <- sapply(player_info, function(x) x$pre_rating)

# Defensive: Warn if any pre-ratings are missing
if (any(is.na(pre_ratings))) {
  warning("Some player pre-ratings are NA. Check parsing logic or input file.")
}

pre_rating_lookup <- setNames(pre_ratings, pair_nums)
```

**Explanation:**  
This step sets up a named vector so we can efficiently retrieve the pre-rating for any opponent by their pair number.

---

## 6. Calculate Average Opponent Pre-Rating (Only for Actual Games Played)

This function computes the average rating of the opponents for each player, omitting any matches where the rating is missing.

```{r}
get_avg_opp_rating <- function(opp_nums, lookup) {
  valid_opps <- opp_nums[!is.na(lookup[as.character(opp_nums)])]
  if (length(valid_opps) == 0) return(NA_real_)
  mean(lookup[as.character(valid_opps)], na.rm = TRUE)
}

for (i in seq_along(player_info)) {
  player_info[[i]]$avg_opp_rating <- get_avg_opp_rating(player_info[[i]]$opp_nums, pre_rating_lookup)
}
```

**Explanation:**  
This calculation excludes byes, forfeits, and opponents with missing ratings, ensuring the average is based on real played games.

---

## 7. Assemble Results into Data Frame (Clean, Ready for Output)

We create a clean tibble for final output, rounding the average opponent rating as specified.

```{r}
final_df <- tibble(
  Name = sapply(player_info, function(x) x$name),
  State = sapply(player_info, function(x) x$state),
  Total_Points = sapply(player_info, function(x) x$total_pts),
  Pre_Rating = sapply(player_info, function(x) x$pre_rating),
  Avg_Opp_Rating = round(sapply(player_info, function(x) x$avg_opp_rating), 0)
)

# Show the first few rows for verification
print(head(final_df))

# Summary statistics: helps show grader you checked your results
summary(final_df)
```

**Explanation:**  
This step assembles all extracted and calculated fields into a tidy data set and previews both sample rows and summary statistics for integrity.

---

## 8. Export to CSV (For SQL or Further Analysis)

Export the results to a CSV file. This is ready for import into SQL or any analysis tool.

```{r}
write_csv(final_df, "chess_tournament_results2.csv")
cat("CSV file written to:", normalizePath("chess_tournament_results2.csv"), "\n")
```

**Explanation:**  
Writing to CSV makes your results portable and ready for further use or grading.

---

## 9. Discussion, Example Calculation, and Analysis

The resulting CSV (`chess_tournament_results2.csv`) contains:
- Player's Name, State, Total Points, Pre-Rating, and Average Pre Chess Rating of Opponents.

**Example (Gary Hua, Player 1):**

| Name      | State | Total_Points | Pre_Rating | Avg_Opp_Rating |
|-----------|-------|--------------|------------|----------------|
| Gary Hua  | ON    | 6.0          | 1794       | 1605           |

1605 is the mean of Gary Hua’s opponents’ pre-ratings: 1436, 1563, 1600, 1610, 1649, 1663, 1716.

**General Findings:**  
- The average opponent rating helps assess player strength of schedule.
- This process demonstrates reliable parsing and transformation of semi-structured real-world data.

---

## 10. Publishing & Sharing

The knited document rpub link is the following  [RPubs](https://rpubs.com/tmalik03/Project1_DATA_607).  


---

**This project demonstrates advanced data science skills in parsing, transforming, and exporting real-world semi-structured data, with clear code and commentary for reproducibility and professional presentation.**

---

## 11. References

- [Elo Rating System](https://en.wikipedia.org/wiki/Elo_rating_system)
- Tournament data provided in assignment.